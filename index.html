<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Deploy Dash</title>
<style>
  :root {
    --bg:#0b0f14; --panel:#121821; --accent:#00d4ff; --accent2:#ff2d6f; --good:#7cff7c; --bad:#ff6b6b;
    --text:#e8f0ff; --muted:#9fb3c8;
  }
  html,body { margin:0; height:100%; background:var(--bg); color:var(--text); font-family:Inter,system-ui,Segoe UI,Arial; }
  #ui { position:fixed; inset:0; pointer-events:none; }
  #hud { position:absolute; top:12px; left:12px; display:flex; gap:12px; pointer-events:auto; }
  .pill { background:var(--panel); border:1px solid #1f2a38; border-radius:10px; padding:8px 12px; font-size:14px; }
  #score { color:var(--good); font-weight:600; }
  #combo { color:var(--accent); }
  #timer { color:var(--accent2); }
  #ship { width:180px; height:10px; border-radius:6px; background:#0e141d; overflow:hidden; border:1px solid #1f2a38; }
  #ship > div { height:100%; background:linear-gradient(90deg,var(--accent),#7cff7c); width:0%; transition:width .15s ease; }
  #canvas { width:100vw; height:100vh; display:block; cursor:crosshair; }
  #start, #gameover { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; }
  .card { background:var(--panel); border:1px solid #1f2a38; border-radius:14px; padding:20px; width:min(520px,90vw); box-shadow:0 10px 30px rgba(0,0,0,.35); }
  .title { font-size:22px; font-weight:700; margin-bottom:8px; }
  .subtitle { color:var(--muted); margin-bottom:16px; }
  .btn { pointer-events:auto; display:inline-block; background:var(--accent); color:#001018; border:none; border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer; }
  .btn.secondary { background:#1b2432; color:var(--text); border:1px solid #2a3a52; }
  .row { display:flex; gap:10px; flex-wrap:wrap; }
  .kbd { background:#0e141d; border:1px solid #1f2a38; border-radius:8px; padding:6px 8px; font-size:13px; }
  #leader { margin-top:12px; font-size:14px; }
  .badge { display:inline-block; padding:4px 8px; border-radius:999px; background:#0e141d; border:1px solid #1f2a38; margin-right:6px; font-size:12px; }
  .hidden { display:none; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="ui">
  <div id="hud">
    <div class="pill">Score: <span id="score">0</span></div>
    <div class="pill">Combo: <span id="combo">x1</span></div>
    <div class="pill">Time: <span id="timer">60</span>s</div>
    <div class="pill">Ship <div id="ship"><div></div></div></div>
  </div>

  <div id="start">
    <div class="card">
      <div class="title">Deploy Dash</div>
      <div class="subtitle">Squash bugs, chain combos, ship the build. 60 seconds. Go viral.</div>
      <div class="row">
        <div class="kbd">Leftâ€‘click: squash</div>
        <div class="kbd">Rightâ€‘click: freeze</div>
        <div class="kbd">Drag: lasso</div>
        <div class="kbd">Space: burst</div>
      </div>
      <div style="margin-top:16px" class="row">
        <button class="btn" id="play">Play</button>
        <button class="btn secondary" id="daily">Daily Challenge</button>
      </div>
      <div id="leader"></div>
    </div>
  </div>

  <div id="gameover" class="hidden">
    <div class="card">
      <div class="title">Build shipped ðŸŽ‰</div>
      <div class="subtitle">Your score: <span id="finalScore">0</span> â€” Combo peak: <span id="finalCombo">x1</span></div>
      <div class="row">
        <span class="badge" id="badge1">âš¡ Speedrunner</span>
        <span class="badge" id="badge2">ðŸ§Š Iceâ€‘Cold</span>
        <span class="badge" id="badge3">ðŸ§¹ Clean Sweep</span>
      </div>
      <div style="margin-top:16px" class="row">
        <button class="btn" id="copy">Copy score</button>
        <button class="btn secondary" id="again">Play again</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let W = canvas.width = window.innerWidth;
  let H = canvas.height = window.innerHeight;

  const hud = {
    scoreEl: document.getElementById('score'),
    comboEl: document.getElementById('combo'),
    timerEl: document.getElementById('timer'),
    shipBar: document.querySelector('#ship > div'),
    start: document.getElementById('start'),
    gameover: document.getElementById('gameover'),
    finalScore: document.getElementById('finalScore'),
    finalCombo: document.getElementById('finalCombo'),
    leader: document.getElementById('leader'),
  };

  const ui = {
    play: document.getElementById('play'),
    daily: document.getElementById('daily'),
    copy: document.getElementById('copy'),
    again: document.getElementById('again'),
  };

  // Game state
  let rngSeed = Date.now() % 1000000;
  let t = 0, dt = 0, last = performance.now();
  let running = false;
  let score = 0;
  let combo = 1;
  let comboTimer = 0;
  let timeLeft = 60;
  let ship = 0;
  let particles = [];
  let bugs = [];
  let powerups = [];
  let freezeTimer = 0;
  let burstReady = true;
  let lasso = null;

  // Utils
  const rand = () => {
    // xorshift32
    rngSeed ^= rngSeed << 13; rngSeed ^= rngSeed >>> 17; rngSeed ^= rngSeed << 5;
    return ((rngSeed >>> 0) / 0xFFFFFFFF);
  };
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, p) => a + (b - a) * p;

  // Entities
  function spawnBug() {
    const r = 16 + rand() * 24;
    const x = 40 + rand() * (W - 80);
    const y = 80 + rand() * (H - 160);
    const vx = (rand() - 0.5) * (freezeTimer ? 0.2 : 1.6);
    const vy = (rand() - 0.5) * (freezeTimer ? 0.2 : 1.6);
    const hp = 1 + Math.floor(rand() * 2);
    bugs.push({ x, y, r, vx, vy, hp, born: t, type: (rand() < 0.2 ? 'conflict' : 'bug') });
  }
  function spawnPowerup() {
    const types = ['auto', 'freeze', 'rollback', 'burst'];
    const type = types[Math.floor(rand() * types.length)];
    const x = 40 + rand() * (W - 80);
    const y = 80 + rand() * (H - 160);
    powerups.push({ x, y, r: 14, type, ttl: 8 });
  }
  function addParticles(x, y, color, n = 12) {
    for (let i = 0; i < n; i++) {
      const a = rand() * Math.PI * 2;
      const s = 60 + rand() * 140;
      particles.push({ x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s, life: 0.5 + rand() * 0.6, color });
    }
  }

  // Input
  let mouse = { x: 0, y: 0, down: false, right: false };
  canvas.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
  canvas.addEventListener('mousedown', e => {
    if (e.button === 0) { mouse.down = true; lasso = { x0: mouse.x, y0: mouse.y, x1: mouse.x, y1: mouse.y }; }
    if (e.button === 2) { mouse.right = true; freezeTimer = 2.5; }
  });
  canvas.addEventListener('mouseup', e => {
    if (e.button === 0) {
      mouse.down = false;
      if (lasso) {
        // Lasso kill
        const x0 = Math.min(lasso.x0, lasso.x1), x1 = Math.max(lasso.x0, lasso.x1);
        const y0 = Math.min(lasso.y0, lasso.y1), y1 = Math.max(lasso.y0, lasso.y1);
        let killed = 0;
        bugs = bugs.filter(b => {
          const hit = b.x > x0 && b.x < x1 && b.y > y0 && b.y < y1;
          if (hit) { killed++; addParticles(b.x, b.y, '#00d4ff'); score += 20 * combo; ship = clamp(ship + 2, 0, 100); }
          return !hit;
        });
        if (killed > 0) { combo = clamp(combo + 1, 1, 20); comboTimer = 3; }
        lasso = null;
      }
    }
    if (e.button === 2) { mouse.right = false; }
  });
  canvas.addEventListener('contextmenu', e => e.preventDefault());
  window.addEventListener('keydown', e => {
    if (e.code === 'Space' && burstReady) {
      burstReady = false;
      addParticles(mouse.x, mouse.y, '#ff2d6f', 40);
      let killed = 0;
      bugs = bugs.filter(b => {
        const d = Math.hypot(b.x - mouse.x, b.y - mouse.y);
        const hit = d < 80;
        if (hit) { killed++; score += 30 * combo; ship = clamp(ship + 3, 0, 100); }
        return !hit;
      });
      if (killed > 0) { combo = clamp(combo + 1, 1, 20); comboTimer = 3; }
      setTimeout(() => burstReady = true, 4000);
    }
  });

  // Core loop
  function update() {
    const now = performance.now();
    dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    if (!running) return;

    t += dt;
    timeLeft = clamp(timeLeft - dt, 0, 999);
    if (timeLeft <= 0 || ship >= 100) return end();

    // Spawns
    if (Math.floor(t * 2) !== Math.floor((t - dt) * 2)) spawnBug();
    if (Math.floor(t) % 5 === 0 && Math.floor((t - dt)) % 5 !== 0) spawnPowerup();

    // Move bugs
    for (const b of bugs) {
      b.x += b.vx * (freezeTimer ? 0.2 : 1) * 60 * dt;
      b.y += b.vy * (freezeTimer ? 0.2 : 1) * 60 * dt;
      if (b.x < 20 || b.x > W - 20) b.vx *= -1;
      if (b.y < 60 || b.y > H - 20) b.vy *= -1;
    }

    // Click squash
    if (mouse.down && !lasso) {
      let hitAny = false;
      for (const b of bugs) {
        const d = Math.hypot(b.x - mouse.x, b.y - mouse.y);
        if (d < b.r) {
          b.hp -= 1;
          addParticles(b.x, b.y, '#7cff7c', 10);
          score += (b.type === 'conflict' ? 40 : 15) * combo;
          ship = clamp(ship + (b.type === 'conflict' ? 3 : 1.5), 0, 100);
          hitAny = true;
        }
      }
      bugs = bugs.filter(b => b.hp > 0);
      if (hitAny) { combo = clamp(combo + 1, 1, 20); comboTimer = 3; }
    }

    // Powerups decay and pickup
    powerups = powerups.filter(p => {
      p.ttl -= dt;
      const d = Math.hypot(p.x - mouse.x, p.y - mouse.y);
      if (d < 24) {
        if (p.type === 'auto') {
          // Autoâ€‘fix: clear weakest bugs
          let cleared = 0;
          bugs.sort((a,b)=>a.hp-b.hp);
          bugs = bugs.filter((b,i)=> {
            const kill = i < 3;
            if (kill) { cleared++; addParticles(b.x,b.y,'#00d4ff',12); score += 20 * combo; ship = clamp(ship + 2, 0, 100); }
            return !kill;
          });
          if (cleared) { combo = clamp(combo + 1, 1, 20); comboTimer = 3; }
        } else if (p.type === 'freeze') {
          freezeTimer = 3.5;
        } else if (p.type === 'rollback') {
          // Rollback hazard wave
          addParticles(p.x, p.y, '#ff6b6b', 20);
          for (let i = 0; i < 4; i++) spawnBug();
          combo = 1; comboTimer = 0;
        } else if (p.type === 'burst') {
          burstReady = true;
        }
        return false;
      }
      return p.ttl > 0;
    });

    // Timers
    if (freezeTimer > 0) freezeTimer -= dt;
    if (comboTimer > 0) comboTimer -= dt; else combo = Math.max(1, combo - 0.02);

    // Particles
    particles = particles.filter(p => {
      p.life -= dt;
      p.x += p.vx * dt; p.y += p.vy * dt;
      p.vx *= 0.98; p.vy *= 0.98;
      return p.life > 0;
    });

    // HUD
    hud.scoreEl.textContent = Math.floor(score);
    hud.comboEl.textContent = 'x' + Math.max(1, combo).toFixed(1);
    hud.timerEl.textContent = Math.ceil(timeLeft);
    hud.shipBar.style.width = ship + '%';
  }

  function draw() {
    // Background grid
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#0b0f14';
    ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#0f1622';
    ctx.lineWidth = 1;
    for (let x = 0; x < W; x += 40) { ctx.beginPath(); ctx.moveTo(x,60); ctx.lineTo(x,H); ctx.stroke(); }
    for (let y = 60; y < H; y += 40) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

    // Header bar
    ctx.fillStyle = '#0e141d';
    ctx.fillRect(0,0,W,48);
    ctx.fillStyle = '#9fb3c8';
    ctx.font = '12px system-ui';
    ctx.fillText('Deploy Dash â€” squash bugs, chain combos, ship fast', 12, 30);

    // Lasso
    if (lasso) {
      lasso.x1 = mouse.x; lasso.y1 = mouse.y;
      ctx.strokeStyle = '#00d4ff';
      ctx.setLineDash([6,4]); ctx.lineWidth = 2;
      ctx.strokeRect(Math.min(lasso.x0,lasso.x1), Math.min(lasso.y0,lasso.y1),
                     Math.abs(lasso.x1-lasso.x0), Math.abs(lasso.y1-lasso.y0));
      ctx.setLineDash([]);
    }

    // Powerups
    for (const p of powerups) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = p.type === 'auto' ? '#00d4ff' :
                      p.type === 'freeze' ? '#7cc8ff' :
                      p.type === 'rollback' ? '#ff6b6b' : '#ffd166';
      ctx.fill();
      ctx.strokeStyle = '#1f2a38'; ctx.stroke();
    }

    // Bugs
    for (const b of bugs) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      const hue = b.type === 'conflict' ? 350 : 200 + Math.sin((t - b.born) * 4) * 20;
      ctx.fillStyle = `hsl(${hue}, 80%, 55%)`;
      ctx.fill();
      ctx.strokeStyle = '#1f2a38'; ctx.stroke();
      // Eyes
      ctx.fillStyle = '#0b0f14';
      ctx.beginPath(); ctx.arc(b.x - b.r/3, b.y - b.r/4, 3, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(b.x + b.r/3, b.y - b.r/4, 3, 0, Math.PI*2); ctx.fill();
    }

    // Particles
    for (const p of particles) {
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, 3, 3);
      ctx.globalAlpha = 1;
    }

    // Freeze overlay
    if (freezeTimer > 0) {
      ctx.fillStyle = 'rgba(124,200,255,0.08)';
      ctx.fillRect(0,0,W,H);
    }
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  function start(seed=null) {
    rngSeed = seed ?? (Date.now() % 1000000);
    t = 0; score = 0; combo = 1; comboTimer = 0; timeLeft = 60; ship = 0;
    bugs = []; powerups = []; particles = []; freezeTimer = 0; burstReady = true; lasso = null;
    hud.start.classList.add('hidden');
    hud.gameover.classList.add('hidden');
    running = true;
  }

  function end() {
    running = false;
    hud.finalScore.textContent = Math.floor(score);
    hud.finalCombo.textContent = 'x' + Math.max(1, combo).toFixed(1);
    hud.gameover.classList.remove('hidden');
    // Leaderboard (local)
    const key = 'deploydash_scores';
    const list = JSON.parse(localStorage.getItem(key) || '[]');
    list.push({ score: Math.floor(score), combo: Math.floor(combo), date: new Date().toISOString() });
    list.sort((a,b)=>b.score-a.score);
    localStorage.setItem(key, JSON.stringify(list.slice(0,10)));
    renderLeader(list.slice(0,10));
    // Badges
    document.getElementById('badge1').style.opacity = score > 1200 ? 1 : 0.3;
    document.getElementById('badge2').style.opacity = freezeTimer > 0 ? 1 : 0.3;
    document.getElementById('badge3').style.opacity = bugs.length === 0 ? 1 : 0.3;
  }

  function renderLeader(list) {
    hud.leader.innerHTML = '<div style="margin-top:10px"><b>Local Top 10</b></div>' +
      list.map((e,i)=>`<div class="pill" style="margin-top:6px">${i+1}. ${e.score} pts â€” combo x${e.combo}</div>`).join('');
  }

  // UI events
  ui.play.addEventListener('click', () => start());
  ui.daily.addEventListener('click', () => {
    // Daily seed: YYYYMMDD
    const d = new Date();
    const seed = d.getFullYear()*10000 + (d.getMonth()+1)*100 + d.getDate();
    start(seed);
  });
  ui.again.addEventListener('click', () => start());
  ui.copy.addEventListener('click', async () => {
    const text = `Deploy Dash â€” Score ${Math.floor(score)} â€” Combo ${Math.max(1,combo).toFixed(1)} â€” ${new Date().toLocaleDateString()}`;
    try { await navigator.clipboard.writeText(text); ui.copy.textContent = 'Copied!'; setTimeout(()=>ui.copy.textContent='Copy score',1200); } catch {}
  });

  // Resize
  window.addEventListener('resize', () => {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
  });

  // Boot
  renderLeader(JSON.parse(localStorage.getItem('deploydash_scores') || '[]'));
  loop();
})();
</script>
</body>
</html>
