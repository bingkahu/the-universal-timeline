<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR: GLITCH HARVESTER</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;700&display=swap');
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Fira Code', monospace; }
        canvas { display: block; filter: contrast(1.4) saturate(1.2); }
        
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 20px; box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .stats { color: #00ff41; text-shadow: 0 0 10px #00ff41; font-size: 18px; }
        .lvl-bar { width: 300px; height: 10px; background: rgba(0,255,65,0.1); border: 1px solid #00ff41; margin-top: 5px; }
        #lvl-fill { width: 0%; height: 100%; background: #00ff41; box-shadow: 0 0 15px #00ff41; }
        .alert { color: #ff0055; font-size: 40px; font-weight: 900; opacity: 0; transition: 0.2s; }
    </style>
</head>
<body>

<div id="hud">
    <div class="stats">
        <div>SECTOR: <span id="sector">1</span></div>
        <div>BUFFER_STRENGTH: <span id="lvl-text">1</span></div>
        <div class="lvl-bar"><div id="lvl-fill"></div></div>
    </div>
    <div id="alert-box" class="alert">CORE_GLITCH_DETECTED</div>
    <div class="stats" style="text-align: right;">
        [SHIFT] HARVEST DATA<br>[SPACE] ASCEND<br>[X] PURGE_BUFFER
    </div>
</div>
<canvas id="game"></canvas>

<script>
/**
 * VETERAN ENGINE V7: THE TESSERACT HARVESTER
 * Logic: OCR-based Pixel Density Sampling & Evolution
 */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const lvlFill = document.getElementById('lvl-fill');
const lvlText = document.getElementById('lvl-text');
const alertBox = document.getElementById('alert-box');

let w, h;
const resize = () => { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; };
window.onresize = resize;
resize();

const state = {
    time: 0, camX: 0, 
    score: 0, exp: 0, level: 1,
    shake: 0, entities: [], particles: [],
    aberration: 0
};

const keys = {};
window.onkeydown = e => keys[e.code] = true;
window.onkeyup = e => keys[e.code] = false;

// --- HARVESTABLE DATA ENTITIES ---
class DataNode {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.char = String.fromCharCode(33 + Math.floor(Math.random() * 94));
        this.weight = Math.random() > 0.8 ? 900 : 300; // OCR weight simulation
        this.size = 20 + Math.random() * 40;
        this.collected = false;
        this.vY = (Math.random() - 0.5) * 2;
    }
    draw() {
        this.y += this.vY;
        ctx.fillStyle = this.weight > 500 ? '#ff00ff' : '#00ff41';
        ctx.font = `${this.weight} ${this.size}px 'Fira Code'`;
        ctx.fillText(this.char, this.x - state.camX, this.y);
    }
}

const player = {
    x: 100, y: 300, vX: 0, vY: 0,
    radius: 30, scanning: false,
    update() {
        // High-responsivity movement
        if(keys.ArrowRight) this.vX += 1.8;
        if(keys.ArrowLeft) this.vX -= 1.8;
        if(keys.Space) this.vY = -10;

        this.vX *= 0.88;
        this.vY += 0.6;
        this.x += this.vX;
        this.y += this.vY;

        if(this.y > h - 100) { this.y = h - 100; this.vY = 0; }
        
        this.scanning = keys.ShiftLeft || keys.ShiftRight;
        if(this.scanning) this.performOCR();
        
        // Progression
        if(state.exp >= 100) {
            state.level++;
            state.exp = 0;
            state.shake = 30;
            lvlText.innerText = state.level;
            this.radius += 5;
            spawnBurst(this.x, this.y, '#fff', 30);
        }
        lvlFill.style.width = state.exp + "%";
    },

    performOCR() {
        const scanWidth = 150 + (state.level * 10);
        const scanHeight = 150 + (state.level * 10);
        
        // Scan visualization
        ctx.strokeStyle = `rgba(0, 255, 65, ${0.2 + Math.sin(state.time * 0.2) * 0.1})`;
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x - state.camX + 50, this.y - 75, scanWidth, scanHeight);

        state.entities.forEach(node => {
            if(!node.collected && 
               node.x > this.x + 50 && node.x < this.x + 50 + scanWidth &&
               node.y > this.y - 75 && node.y < this.y - 75 + scanHeight) {
                
                node.collected = true;
                state.exp += node.weight > 500 ? 15 : 5;
                state.score += node.weight;
                state.shake = 5;
                spawnBurst(node.x, node.y, node.weight > 500 ? '#ff00ff' : '#00ff41', 10);
            }
        });
    },

    draw() {
        ctx.save();
        ctx.translate(this.x - state.camX, this.y);
        
        // Kirby-OS Core
        const grad = ctx.createRadialGradient(0,0,5, 0,0,this.radius);
        grad.addColorStop(0, '#fff');
        grad.addColorStop(1, this.scanning ? '#00ff41' : '#ffb6c1');
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Digital Face
        ctx.fillStyle = '#000';
        ctx.fillRect(5, -10, 4, 15);
        ctx.fillRect(15, -10, 4, 15);
        ctx.restore();
    }
};

function spawnBurst(x, y, color, count) {
    for(let i=0; i<count; i++) {
        state.particles.push({
            x, y, vX: (Math.random()-0.5)*20, vY: (Math.random()-0.5)*20,
            color, life: 1
        });
    }
}

// --- INITIALIZE WORLD ---
function spawnCluster(startX) {
    for(let i=0; i<15; i++) {
        state.entities.push(new DataNode(startX + Math.random() * 800, 100 + Math.random() * (h - 300)));
    }
}
spawnCluster(400);

// --- MAIN LOOP ---
function loop() {
    state.time++;
    
    // Clear & Chromatic Aberration Simulation
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(0, 0, w, h);

    state.camX += (player.x - w/3 - state.camX) * 0.1;

    if(state.shake > 0) {
        ctx.translate((Math.random()-0.5)*state.shake, (Math.random()-0.5)*state.shake);
        state.shake *= 0.9;
    }

    // World Rendering
    state.entities = state.entities.filter(e => !e.collected);
    state.entities.forEach(e => e.draw());

    state.particles.forEach((p, i) => {
        p.x += p.vX; p.y += p.vY; p.life -= 0.03;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.fillRect(p.x - state.camX, p.y, 4, 4);
        if(p.life <= 0) state.particles.splice(i, 1);
    });
    ctx.globalAlpha = 1;

    player.update();
    player.draw();

    // Infinity Spawner
    if(state.entities.length < 20) spawnCluster(player.x + w);

    // Brainrot Difficulty Spike
    if(state.level % 5 === 0) {
        alertBox.style.opacity = Math.sin(state.time * 0.5);
    } else {
        alertBox.style.opacity = 0;
    }

    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
