<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>10D Shape Simulator</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: sans-serif;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 8px;
    }
    label { display: block; font-size: 12px; }
  </style>
</head>
<body>

<div id="ui">
  <label>Rotate X–W <input type="range" min="0" max="6.28" step="0.01" id="xw"></label>
  <label>Rotate Y–W <input type="range" min="0" max="6.28" step="0.01" id="yw"></label>
  <label>Rotate W–V <input type="range" min="0" max="6.28" step="0.01" id="wv"></label>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158/examples/js/controls/OrbitControls.js"></script>

<script>
/* =========================
   THREE.JS SETUP
========================= */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);

/* =========================
   5D HYPERCUBE
========================= */

// Create vertices of a 5D hypercube
let vertices5D = [];
for (let i = 0; i < 32; i++) {
  vertices5D.push([
    (i & 1) ? 1 : -1,
    (i & 2) ? 1 : -1,
    (i & 4) ? 1 : -1,
    (i & 8) ? 1 : -1,
    (i & 16) ? 1 : -1
  ]);
}

// Generate edges
let edges = [];
for (let i = 0; i < 32; i++) {
  for (let j = i + 1; j < 32; j++) {
    let diff = 0;
    for (let d = 0; d < 5; d++) {
      if (vertices5D[i][d] !== vertices5D[j][d]) diff++;
    }
    if (diff === 1) edges.push([i, j]);
  }
}

/* =========================
   ROTATION & PROJECTION
========================= */

function rotate5D(p, a, b, angle) {
  let x = p[a], y = p[b];
  p[a] = x * Math.cos(angle) - y * Math.sin(angle);
  p[b] = x * Math.sin(angle) + y * Math.cos(angle);
}

function project5Dto3D(p) {
  const scaleW = 1 / (2 - p[3]);
  const scaleV = 1 / (2 - p[4]);
  return new THREE.Vector3(
    p[0] * scaleW * scaleV,
    p[1] * scaleW * scaleV,
    p[2] * scaleW * scaleV
  );
}

/* =========================
   GEOMETRY
========================= */

const material = new THREE.LineBasicMaterial({ color: 0x00ffff });
let geometry = new THREE.BufferGeometry();
let lineSegments = new THREE.LineSegments(geometry, material);
scene.add(lineSegments);

/* =========================
   UI CONTROLS
========================= */

const sliders = {
  xw: document.getElementById("xw"),
  yw: document.getElementById("yw"),
  wv: document.getElementById("wv")
};

/* =========================
   ANIMATION LOOP
========================= */

function animate() {
  requestAnimationFrame(animate);

  let points = vertices5D.map(v => {
    let p = [...v];
    rotate5D(p, 0, 3, sliders.xw.value);
    rotate5D(p, 1, 3, sliders.yw.value);
    rotate5D(p, 3, 4, sliders.wv.value);
    return project5Dto3D(p);
  });

  let positions = [];
  edges.forEach(([a, b]) => {
    positions.push(...points[a].toArray());
    positions.push(...points[b].toArray());
  });

  geometry.setAttribute(
    'position',
    new THREE.Float32BufferAttribute(positions, 3)
  );

  geometry.computeBoundingSphere();
  renderer.render(scene, camera);
}

animate();

window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
