<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>who doesnt love penis</title>
<meta name="description" content="Shardstorm — procedural spells, relic synergies, evolving shard bosses. Roguelike arena built for chaos."/>
<style>
  :root {
    --bg:#0b0f14; --panel:#121821; --border:#1f2a38; --text:#e8f0ff; --muted:#9fb3c8;
    --accent:#00d4ff; --accent2:#ff2d6f; --good:#7cff7c; --bad:#ff6b6b; --gold:#ffd166; --violet:#b388ff;
  }
  html,body { margin:0; height:100%; background:var(--bg); color:var(--text); font-family:Inter,system-ui,Segoe UI,Arial; }
  #game { width:100vw; height:100vh; display:block; cursor:crosshair; }
  .hidden { display:none !important; }
  #ui { position:fixed; inset:0; pointer-events:none; }
  #hud { position:absolute; top:12px; left:12px; display:flex; gap:12px; pointer-events:auto; flex-wrap:wrap; }
  .pill { background:var(--panel); border:1px solid var(--border); border-radius:10px; padding:8px 12px; font-size:14px; }
  #score { color:var(--good); font-weight:700; }
  #wave { color:var(--accent); }
  #hp { color:var(--bad); }
  #mana { color:var(--violet); }
  #seed { color:var(--muted); }
  #topright { position:absolute; top:12px; right:12px; display:flex; gap:8px; pointer-events:auto; }
  .btn { pointer-events:auto; display:inline-flex; align-items:center; gap:8px; background:var(--accent); color:#001018; border:none; border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer; }
  .btn.secondary { background:#1b2432; color:var(--text); border:1px solid #2a3a52; }
  .btn.small { padding:6px 10px; font-size:12px; }
  #start, #gameover, #codex { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; }
  .card { background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:20px; width:min(820px,92vw); box-shadow:0 10px 30px rgba(0,0,0,.35); }
  .title { font-size:22px; font-weight:700; margin-bottom:8px; }
  .subtitle { color:var(--muted); margin-bottom:16px; }
  .row { display:flex; gap:10px; flex-wrap:wrap; }
  .kbd { background:#0e141d; border:1px solid var(--border); border-radius:8px; padding:6px 8px; font-size:13px; }
  .list { margin-top:10px; }
  .list .pill { margin-top:6px; }
  #toast { position:absolute; bottom:12px; left:12px; background:#0e141d; border:1px solid var(--border); border-radius:10px; padding:8px 12px; font-size:13px; pointer-events:none; opacity:0; transform:translateY(8px); transition:opacity .2s, transform .2s; }
  #toast.show { opacity:1; transform:translateY(0); }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="ui">
  <div id="hud">
    <div class="pill">Score: <span id="score">0</span></div>
    <div class="pill">Wave: <span id="wave">1</span></div>
    <div class="pill">HP: <span id="hp">100</span></div>
    <div class="pill">Mana: <span id="mana">100</span></div>
    <div class="pill">Seed: <span id="seed">—</span></div>
  </div>

  <div id="topright">
    <button class="btn small" id="btnCodex">Codex</button>
    <button class="btn small" id="btnMute">Mute</button>
    <button class="btn small secondary" id="btnDaily">Daily</button>
  </div>

  <div id="toast">Unlocked!</div>

  <!-- START -->
  <div id="start">
    <div class="card">
      <div class="title">Shardstorm — Roguelike Arena</div>
      <div class="subtitle">Craft spells from runes, stack relic synergies, and shatter evolving shard bosses.</div>
      <div class="row">
        <div class="kbd">WASD: move</div>
        <div class="kbd">Mouse: aim</div>
        <div class="kbd">Left‑click: cast</div>
        <div class="kbd">Right‑click: dash</div>
        <div class="kbd">Q/E: cycle spells</div>
        <div class="kbd">Space: overcast</div>
      </div>
      <div style="margin-top:16px" class="row">
        <button class="btn" id="play">Play</button>
        <button class="btn secondary" id="daily">Daily Seed</button>
      </div>
      <div class="list" id="leader"></div>
    </div>
  </div>

  <!-- GAME OVER -->
  <div id="gameover" class="hidden">
    <div class="card">
      <div class="title">Run complete</div>
      <div class="subtitle">Score: <span id="finalScore">0</span> — Wave: <span id="finalWave">1</span></div>
      <div class="row">
        <button class="btn" id="again">Play again</button>
        <button class="btn secondary" id="copy">Copy score</button>
      </div>
    </div>
  </div>

  <!-- CODEX -->
  <div id="codex" class="hidden">
    <div class="card">
      <div class="title">Codex — Spells & Relics</div>
      <div class="subtitle">Procedural spells are built from runes. Relics add synergies and mutate behavior.</div>
      <div class="list" id="codexList"></div>
      <div class="row" style="margin-top:12px">
        <button class="btn secondary" id="closeCodex">Close</button>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================
   AUDIO (WebAudio)
   ========================= */
const Audio = (() => {
  let ctx, master, sfxGain, musicGain, muted=false;
  function init(){
    if (ctx) return;
    ctx = new (window.AudioContext||window.webkitAudioContext)();
    master = ctx.createGain(); master.connect(ctx.destination);
    sfxGain = ctx.createGain(); sfxGain.gain.value = 0.8; sfxGain.connect(master);
    musicGain = ctx.createGain(); musicGain.gain.value = 0.25; musicGain.connect(master);
    const o1 = ctx.createOscillator(); o1.type='sawtooth'; o1.frequency.value=96;
    const o2 = ctx.createOscillator(); o2.type='sawtooth'; o2.frequency.value=192;
    const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=900;
    o1.connect(lp); o2.connect(lp); lp.connect(musicGain);
    o1.start(); o2.start();
  }
  function play(type='cast'){
    if (!ctx || muted) return;
    const o = ctx.createOscillator(); const g = ctx.createGain();
    o.type = 'square';
    o.frequency.value = type==='hit' ? 520 : type==='dash' ? 220 : type==='boss' ? 160 : 360;
    g.gain.value = 0.2; o.connect(g); g.connect(sfxGain);
    o.start(); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.15); o.stop(ctx.currentTime+0.16);
  }
  function toggle(){ muted=!muted; master.gain.value = muted?0:1; }
  return { init, play, toggle, get muted(){return muted;} };
})();

/* =========================
   UTIL
   ========================= */
const Util = (() => {
  let seed = Date.now()%1000000;
  function setSeed(s){ seed=s; }
  function rand(){ seed^=seed<<13; seed^=seed>>>17; seed^=seed<<5; return ((seed>>>0)/0xFFFFFFFF); }
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,p)=>a+(b-a)*p;
  const now=()=>performance.now();
  function vec(x=0,y=0){ return {x,y}; }
  function angle(x1,y1,x2,y2){ return Math.atan2(y2-y1,x2-x1); }
  function fmt(n){ return n.toLocaleString(); }
  return { setSeed, rand, clamp, lerp, now, vec, angle, fmt };
})();

/* =========================
   CONTENT REGISTRY
   ========================= */
const Content = (() => {
  // Runes define procedural spell traits
  const Runes = [
    { id:'bolt',   desc:'Straight projectile' },
    { id:'pierce', desc:'Pass through enemies' },
    { id:'split',  desc:'Split on hit' },
    { id:'orbit',  desc:'Orbit around player' },
    { id:'tether', desc:'Link enemies and share damage' },
    { id:'nova',   desc:'Radial burst' },
    { id:'drain',  desc:'Restore mana on hit' },
    { id:'ignite', desc:'Damage over time' },
  ];
  // Relics add synergies
  const Relics = [
    { id:'glass',   name:'Glass Focus', desc:'+40% damage, -20% HP' },
    { id:'battery', name:'Arc Battery', desc:'+30% cast speed, +10 mana regen' },
    { id:'echo',    name:'Echo Core',   desc:'Spells repeat after delay' },
    { id:'chain',   name:'Chain Node',  desc:'Hits chain to nearby enemies' },
    { id:'vortex',  name:'Vortex Lens', desc:'Pulls enemies slightly on hit' },
    { id:'bloom',   name:'Bloom Seed',  desc:'Chance to spawn healing orbs' },
  ];
  // Enemies
  const Enemies = [
    { id:'shard',  hp:20,  speed:1.2, score:10 },
    { id:'wisp',   hp:12,  speed:1.6, score:8 },
    { id:'brute',  hp:40,  speed:0.8, score:20 },
  ];
  // Boss shards evolve by splitting
  const Bosses = [
    { id:'Prime Shard', hp:400, phases:3, split:3, score:500 },
  ];
  return { Runes, Relics, Enemies, Bosses };
})();

/* =========================
   GAME
   ========================= */
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W = canvas.width = window.innerWidth;
  let H = canvas.height = window.innerHeight;

  // HUD
  const hud = {
    score: document.getElementById('score'),
    wave: document.getElementById('wave'),
    hp: document.getElementById('hp'),
    mana: document.getElementById('mana'),
    seed: document.getElementById('seed'),
    start: document.getElementById('start'),
    gameover: document.getElementById('gameover'),
    finalScore: document.getElementById('finalScore'),
    finalWave: document.getElementById('finalWave'),
    leader: document.getElementById('leader'),
    toast: document.getElementById('toast'),
    codex: document.getElementById('codex'),
    codexList: document.getElementById('codexList'),
  };

  // UI
  const ui = {
    play: document.getElementById('play'),
    daily: document.getElementById('daily'),
    again: document.getElementById('again'),
    copy: document.getElementById('copy'),
    btnCodex: document.getElementById('btnCodex'),
    closeCodex: document.getElementById('closeCodex'),
    btnMute: document.getElementById('btnMute'),
    btnDaily: document.getElementById('btnDaily'),
  };

  // State
  let running=false, t=0, dt=0, last=Util.now();
  let score=0, wave=1;
  const player = { x:W/2, y:H/2, vx:0, vy:0, speed:220, hp:100, mana:100, dash:0, inv:0 };
  const input = { w:false,a:false,s:false,d:false, mx:W/2, my:H/2, l:false, r:false, q:false, e:false, space:false };
  let spells=[], projectiles=[], enemies=[], particles=[], orbs=[];
  let currentSpell=0;
  let seedVal = Date.now()%1000000;

  // Leaderboard (local)
  function saveScore(){
    const key='shardstorm_scores';
    const list = JSON.parse(localStorage.getItem(key)||'[]');
    list.push({ score:Math.floor(score), wave, date:new Date().toISOString() });
    list.sort((a,b)=>b.score-a.score);
    localStorage.setItem(key, JSON.stringify(list.slice(0,10)));
    renderLeader(list.slice(0,10));
  }
  function renderLeader(list){
    hud.leader.innerHTML = '<div style="margin-top:10px"><b>Local Top 10</b></div>' +
      list.map((e,i)=>`<div class="pill">${i+1}. ${Util.fmt(e.score)} pts — wave ${e.wave}</div>`).join('');
  }

  // Toast
  let toastTimer=0;
  function toast(msg){ hud.toast.textContent=msg; hud.toast.classList.add('show'); toastTimer=1.8; }

  // Input
  window.addEventListener('mousemove', e=>{ input.mx=e.clientX; input.my=e.clientY; });
  window.addEventListener('mousedown', e=>{ if(e.button===0) input.l=true; if(e.button===2) input.r=true; });
  window.addEventListener('mouseup', e=>{ if(e.button===0) input.l=false; if(e.button===2) input.r=false; });
  window.addEventListener('contextmenu', e=>e.preventDefault());
  window.addEventListener('keydown', e=>{
    if(e.key==='w'||e.key==='W') input.w=true;
    if(e.key==='a'||e.key==='A') input.a=true;
    if(e.key==='s'||e.key==='S') input.s=true;
    if(e.key==='d'||e.key==='D') input.d=true;
    if(e.key==='q'||e.key==='Q') cycleSpell(-1);
    if(e.key==='e'||e.key==='E') cycleSpell(+1);
    if(e.code==='Space') castOver();
  });
  window.addEventListener('keyup', e=>{
    if(e.key==='w'||e.key==='W') input.w=false;
    if(e.key==='a'||e.key==='A') input.a=false;
    if(e.key==='s'||e.key==='S') input.s=false;
    if(e.key==='d'||e.key==='D') input.d=false;
  });

  // UI events
  ui.play.addEventListener('click', ()=>start(seedVal));
  ui.daily.addEventListener('click', ()=>{
    const d=new Date(); const s=d.getFullYear()*10000+(d.getMonth()+1)*100+d.getDate();
    start(s);
  });
  ui.again.addEventListener('click', ()=>start(seedVal));
  ui.copy.addEventListener('click', async ()=>{
    const text=`Shardstorm — Score ${Math.floor(score)} — Wave ${wave} — ${new Date().toLocaleDateString()}`;
    try{ await navigator.clipboard.writeText(text); toast('Copied score'); }catch{}
  });
  ui.btnCodex.addEventListener('click', ()=>{ hud.codex.classList.remove('hidden'); renderCodex(); });
  ui.closeCodex.addEventListener('click', ()=>hud.codex.classList.add('hidden'));
  ui.btnMute.addEventListener('click', ()=>{ Audio.toggle(); toast(Audio.muted?'Muted':'Unmuted'); });
  ui.btnDaily.addEventListener('click', ()=>{
    const d=new Date(); const s=d.getFullYear()*10000+(d.getMonth()+1)*100+d.getDate();
    start(s);
  });

  // Resize
  window.addEventListener('resize', ()=>{ W=canvas.width=window.innerWidth; H=canvas.height=window.innerHeight; });

  // Codex
  function renderCodex(){
    const spellsList = spells.map((s,i)=>`<div class="pill"><b>Spell ${i+1}</b> — ${s.name} — ${s.desc}</div>`).join('');
    const runesList = Content.Runes.map(r=>`<div class="pill">Rune: <b>${r.id}</b> — ${r.desc}</div>`).join('');
    const relicsList = Content.Relics.map(r=>`<div class="pill">Relic: <b>${r.name}</b> — ${r.desc}</div>`).join('');
    hud.codexList.innerHTML = `<div><b>Current Spells</b></div>${spellsList}<div style="margin-top:8px"><b>Runes</b></div>${runesList}<div style="margin-top:8px"><b>Relics</b></div>${relicsList}`;
  }

  // Spells
  function cycleSpell(dir){ currentSpell=(currentSpell+dir+spells.length)%spells.length; toast('Spell: '+spells[currentSpell].name); }
  function cast(){
    const s=spells[currentSpell];
    if(player.mana < s.cost) return;
    player.mana = Math.max(0, player.mana - s.cost);
    Audio.play('cast');
    s.cast(player.x, player.y, input.mx, input.my);
  }
  function castOver(){
    const s=spells[currentSpell];
    if(player.mana < s.cost*2) return;
    player.mana = Math.max(0, player.mana - s.cost*2);
    Audio.play('boss');
    s.over(player.x, player.y, input.mx, input.my);
  }

  // Procedural spell factory
  function makeSpell(name, desc, config){
    const base = Object.assign({ speed:420, dmg:12, pierce:0, split:0, cost:8, color:'#00d4ff' }, config);
    return {
      name, desc, cost:base.cost,
      cast(x,y,mx,my){
        const ang=Util.angle(x,y,mx,my);
        const vx=Math.cos(ang)*base.speed, vy=Math.sin(ang)*base.speed;
        projectiles.push({ x, y, vx, vy, r:6, dmg:base.dmg, pierce:base.pierce, split:base.split, color:base.color, life:1.2 });
      },
      over(x,y,mx,my){
        // Nova burst
        for(let i=0;i<16;i++){
          const a=(Math.PI*2)*(i/16);
          const vx=Math.cos(a)*base.speed*0.7, vy=Math.sin(a)*base.speed*0.7;
          projectiles.push({ x, y, vx, vy, r:7, dmg:base.dmg*1.5, pierce:base.pierce+1, split:base.split, color:base.color, life:1.0 });
        }
      }
    };
  }

  // Build initial spellbook
  function buildSpells(){
    spells = [
      makeSpell('Bolt', 'Straight piercer', { dmg:14, pierce:1, cost:6, color:'#7cff7c' }),
      makeSpell('Splitter', 'Splits on hit', { dmg:10, split:2, cost:8, color:'#ffd166' }),
      makeSpell('Orbit', 'Orbiting blades', { dmg:8, cost:5, color:'#ff2d6f' }),
    ];
  }

  // Enemies
  function spawnWave(n=10){
    enemies=[];
    for(let i=0;i<n;i++){
      const e = Content.Enemies[Math.floor(Util.rand()*Content.Enemies.length)];
      const x = Util.rand()<0.5 ? -40 : W+40;
      const y = 80 + Util.rand()*(H-160);
      enemies.push({ type:e.id, hp:e.hp, speed:e.speed, x, y, vx:0, vy:0, r:14, score:e.score });
    }
    // Boss every 5 waves
    if(wave%5===0){
      const b = Content.Bosses[0];
      enemies.push({ type:'boss', name:b.id, hp:b.hp, speed:0.9, x:W/2, y:80, vx:0, vy:0, r:28, score:b.score, phase:1, split:b.split });
      toast('Boss: '+b.id);
    }
  }

  // Particles
  function addParticles(x,y,color,n=12){
    for(let i=0;i<n;i++){
      const a=Util.rand()*Math.PI*2; const s=60+Util.rand()*140;
      particles.push({ x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:0.5+Util.rand()*0.6,color });
    }
  }

  // Orbs (healing/mana)
  function spawnOrb(x,y,type='heal'){
    orbs.push({ x,y,r:6,type,ttl:6 });
  }

  // Update
  function update(){
    const now=Util.now(); dt=Math.min(0.033,(now-last)/1000); last=now;
    if(!running) return;
    t+=dt;

    // Input → movement
    const ax = (input.d?1:0) - (input.a?1:0);
    const ay = (input.s?1:0) - (input.w?1:0);
    const len = Math.hypot(ax,ay)||1;
    player.vx = (ax/len)*player.speed;
    player.vy = (ay/len)*player.speed;
    player.x = Util.clamp(player.x + player.vx*dt, 20, W-20);
    player.y = Util.clamp(player.y + player.vy*dt, 60, H-20);

    // Dash
    if(input.r && player.dash<=0){ player.dash=0.25; Audio.play('dash'); }
    if(player.dash>0){
      player.dash-=dt;
      player.x += Math.cos(Util.angle(player.x,player.y,input.mx,input.my))*600*dt;
      player.y += Math.sin(Util.angle(player.x,player.y,input.mx,input.my))*600*dt;
    }

    // Mana regen
    player.mana = Math.min(100, player.mana + 12*dt);

    // Casting
    if(input.l) cast();

    // Projectiles
    projectiles = projectiles.filter(p=>{
      p.life-=dt; p.x+=p.vx*dt; p.y+=p.vy*dt;
      return p.life>0 && p.x>-40 && p.x<W+40 && p.y>40 && p.y<H+40;
    });

    // Enemies move toward player
    for(const e of enemies){
      const ang=Util.angle(e.x,e.y,player.x,player.y);
      e.vx=Math.cos(ang)*e.speed*60; e.vy=Math.sin(ang)*e.speed*60;
      e.x+=e.vx*dt; e.y+=e.vy*dt;
    }

    // Collisions: projectiles vs enemies
    for(const p of projectiles){
      for(const e of enemies){
        const d=Math.hypot(p.x-e.x,p.y-e.y);
        if(d < p.r + e.r){
          e.hp -= p.dmg;
          addParticles(e.x,e.y,p.color,10);
          Audio.play('hit');
          score += 4;
          if(p.split>0){
            for(let i=0;i<p.split;i++){
              const a=Util.rand()*Math.PI*2;
              projectiles.push({ x:e.x, y:e.y, vx:Math.cos(a)*p.vx*0.6, vy:Math.sin(a)*p.vy*0.6, r:5, dmg:p.dmg*0.6, pierce:0, split:0, color:p.color, life:0.6 });
            }
            p.split=0;
          }
          if(p.pierce>0){ p.pierce--; } else { p.life=0; }
        }
      }
    }

    // Enemy death & boss split
    enemies = enemies.filter(e=>{
      if(e.hp<=0){
        score += e.score;
        addParticles(e.x,e.y,'#ff2d6f',16);
        if(e.type==='boss' && e.split>0){
          for(let i=0;i<e.split;i++){
            enemies.push({ type:'shard', hp:40, speed:1.4, x:e.x, y:e.y, vx:0, vy:0, r:14, score:20 });
          }
        } else if(Util.rand()<0.15){ spawnOrb(e.x,e.y, Util.rand()<0.5?'heal':'mana'); }
        return false;
      }
      return true;
    });

    // Orbs pickup
    orbs = orbs.filter(o=>{
      o.ttl-=dt;
      const d=Math.hypot(o.x-player.x,o.y-player.y);
      if(d<14){
        if(o.type==='heal') player.hp = Math.min(100, player.hp+12);
        else player.mana = Math.min(100, player.mana+20);
        addParticles(o.x,o.y, o.type==='heal'?'#7cff7c':'#00d4ff', 10);
        return false;
      }
      return o.ttl>0;
    });

    // Player damage
    for(const e of enemies){
      const d=Math.hypot(e.x-player.x,e.y-player.y);
      if(d < e.r+10 && player.inv<=0){
        player.hp -= 8;
        player.inv = 0.4;
        addParticles(player.x,player.y,'#ff6b6b',12);
        if(player.hp<=0) return end();
      }
    }
    if(player.inv>0) player.inv-=dt;

    // Wave clear
    if(enemies.length===0){
      wave++;
      toast('Wave '+wave);
      spawnWave(8 + Math.floor(wave*1.2));
    }

    // HUD
    hud.score.textContent = Math.floor(score);
    hud.wave.textContent = wave;
    hud.hp.textContent = Math.max(0, Math.floor(player.hp));
    hud.mana.textContent = Math.floor(player.mana);

    // Toast decay
    if(toastTimer>0){ toastTimer-=dt; if(toastTimer<=0) hud.toast.classList.remove('show'); }
  }

  // Draw
  function draw(){
    ctx.clearRect(0,0,W,H);
    // Grid
    ctx.fillStyle='#0b0f14'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='#0f1622'; ctx.lineWidth=1;
    for(let x=0;x<W;x+=40){ ctx.beginPath(); ctx.moveTo(x,60); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=60;y<H;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

    // Header
    ctx.fillStyle='#0e141d'; ctx.fillRect(0,0,W,48);
    ctx.fillStyle='#9fb3c8'; ctx.font='12px system-ui';
    ctx.fillText('Shardstorm — procedural spells, relic synergies, evolving shard bosses', 12, 30);

    // Orbs
    for(const o of orbs){
      ctx.beginPath(); ctx.arc(o.x,o.y,o.r,0,Math.PI*2);
      ctx.fillStyle = o.type==='heal'?'#7cff7c':'#00d4ff'; ctx.fill();
      ctx.strokeStyle='#1f2a38'; ctx.stroke();
    }

    // Enemies
    for(const e of enemies){
      ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2);
      ctx.fillStyle = e.type==='boss' ? '#ff2d6f' : (e.type==='brute' ? '#ffd166' : '#b388ff');
      ctx.fill(); ctx.strokeStyle='#1f2a38'; ctx.stroke();
    }

    // Projectiles
    for(const p of projectiles){
      ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      ctx.fillStyle=p.color; ctx.fill();
    }

    // Particles
    particles = particles.filter(pt=>{
      pt.life-=dt; pt.x+=pt.vx*dt; pt.y+=pt.vy*dt; pt.vx*=0.98; pt.vy*=0.98;
      if(pt.life>0){
        ctx.globalAlpha=Math.max(0,pt.life);
        ctx.fillStyle=pt.color; ctx.fillRect(pt.x,pt.y,3,3);
        ctx.globalAlpha=1;
        return true;
      }
      return false;
    });

    // Player
    ctx.beginPath(); ctx.arc(player.x,player.y,10,0,Math.PI*2);
    ctx.fillStyle='#e8f0ff'; ctx.fill(); ctx.strokeStyle='#1f2a38'; ctx.stroke();
  }

  function loop(){ update(); draw(); requestAnimationFrame(loop); }

  function start(seed){
    Audio.init();
    Util.setSeed(seed); seedVal=seed;
    hud.seed.textContent = seed;
    hud.start.classList.add('hidden'); hud.gameover.classList.add('hidden');
    score=0; wave=1; player.hp=100; player.mana=100; player.dash=0; player.inv=0;
    projectiles=[]; enemies=[]; particles=[]; orbs=[];
    buildSpells(); spawnWave(10);
    running=true;
  }

  function end(){
    running=false;
    hud.finalScore.textContent = Math.floor(score);
    hud.finalWave.textContent = wave;
    hud.gameover.classList.remove('hidden');
    saveScore();
  }

  // Boot
  renderLeader(JSON.parse(localStorage.getItem('shardstorm_scores')||'[]'));
  loop();
})();
</script>
</body>
</html>
